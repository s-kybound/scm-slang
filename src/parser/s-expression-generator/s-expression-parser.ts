/**
 * This parser works directly on the tokens generated by the lexer
 * to produce an AST, represented by an ordered list of s-expressions.
 * 
 * In the future, this will allow for the implementation of a macro system,
 * working on this s-expression AST before reducing it to a more efficient
 * AST representation.
 */

import { Token } from "../types/token";
import { TokenType } from "../types/token-type";
import { Location } from "../types/location";
import { Atomic, Expression } from "../types/node-types"
import * as ParserError from "../parser-error";
import { Group } from "./grouping";

export class SExpressionParser {
  private readonly source: string;
  private readonly tokens: Token[];
  private readonly ast: Expression[];
  private current: number = 0;

  constructor(source: string, tokens: Token[]) {
    this.source = source;
    this.tokens = tokens;
    this.ast = [];
  }

  private advance(): Token {
    if (!this.isAtEnd()) this.current++;
    return this.previous();
  }

  private isAtEnd(): boolean {
    return this.current >= this.tokens.length;
  }

  private previous(): Token {
    return this.tokens[this.current - 1];
  }

  /**
   * Returns the location of a token.
   * @param token A token.
   * @returns The location of the token.
   */
  private toLocation(token: Token): Location {
    return new Location(token.pos, token.endPos);
  }

  /**
   * Returns a group of associated tokens.
   * Tokens are grouped by level of parentheses.
   *
   * @param openparen The type of opening parenthesis.
   * @returns A group of tokens or groups of tokens.
   */
  private grouping(openparen?: Token): Group {
    const elements: (Token | Group)[] = [];
    let inList = false;
    if (openparen) {
      inList = true;
      elements.push(openparen);
    }
    do {
      let c = this.advance();
      switch (c.type) {
        case TokenType.LEFT_PAREN:
        case TokenType.LEFT_BRACKET:
          const innerGroup = this.grouping(c);
          elements.push(innerGroup);
          break;
        case TokenType.RIGHT_PAREN:
        case TokenType.RIGHT_BRACKET:
          if (!inList) {
            throw new ParserError.UnexpectedTokenError(this.source, c.pos, c);
          }
          // add the parenthesis to the current group
          elements.push(c);
          inList = false;
          break;
        case TokenType.APOSTROPHE:
        case TokenType.BACKTICK:
        case TokenType.HASH:
        case TokenType.COMMA:
        case TokenType.COMMA_AT:
          // These special notations are converted to their
          // corresponding "procedure-style" tokens.
          const convertedToken = c.convertToken();
          // add this token to the next group
          const nextGroup = this.grouping();
          nextGroup.admit(convertedToken);
          // modify the next group's location
          elements.push(nextGroup);
          break;
        case TokenType.NUMBER:
        case TokenType.BOOLEAN:
        case TokenType.STRING:
        case TokenType.DOT:
          elements.push(c);
          break;
        case TokenType.EOF:
          if (inList) {
            throw new ParserError.UnexpectedEOFError(this.source, c.pos);
          } else {
            elements.push(c);
          }
          break;
        default:
          throw new ParserError.UnexpectedTokenError(this.source, c.pos, c);
      }
    } while (inList);
    return new Group(elements);
  }

  /**
   * Parse an expression.
   * @param expr A token or a group of tokens.
   * @returns
   */
  private parseExpression(expr: Token | Group): Expression {
    // Discern the type of expression
    if (expr instanceof Token) {
      return this.parseToken(expr);
    }
    // It's a group
    return this.parseGroup(expr);
  }

  /**
   * Parses a sequence of tokens into an AST.
   *
   * @param group A group of tokens.
   * @returns A sequence of s-expressions.
   */
  parse(): Expression[] {
    // collect all top-level elements
    const topElements: Expression[] = [];
    while (!this.isAtEnd()) {
      const currentGroup = this.grouping();
      const convertedElement = this.parseExpression(currentGroup);
      console.log(currentGroup);
      topElements.push(convertedElement);
    }
    return topElements;
  }
}
